{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ansible - Good and Bad Practices","text":"<p>A collection of good and bad Ansible code examples.</p> <ul> <li>Name your tasks</li> <li>Use Modules before run-commands</li> <li>Use native yaml syntax</li> <li>Use the copy-module or template-module instead of lineinfile-module</li> <li>Avoid unintended side effects when running playbooks</li> <li>Turn off gather_facts if not needed</li> <li>Prefix your variables</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to contribute you can create a merge request so other colleagues will discuss the code with you. Make sure to add both a good and a bad practice to your code example.</p> <p>Make sure that: - your code won't contain credentials - you've commented the code why it is a good or bad practice - your code can be easily run, so please add a full playbook if possible - be open to discuss with your colleagues</p> <p>If you want to change, discuss or view the code - feel free to visit the repository: https://github.com/telekom-mms/ansible-bad-and-good-practices</p>"},{"location":"avoid_sideeffects/","title":"Avoid unintended side effects when running playbooks","text":"<p>When writing tasks that can target different environments, make sure that the playbook-run only targets the environments that you really want to change.</p>"},{"location":"avoid_sideeffects/#bad","title":"Bad","text":"<p>Suppose you have a list of environments defined in the <code>group_vars</code>:</p> <pre><code>environments:\n  - dev\n  - qa\n  - prod\n</code></pre> <p>In the playbook you can delete databases based on the environment:</p> <pre><code>---\n- hosts:\n    - localhost\n  vars:\n    db_list_backend:\n      - cms\n      - fms\n  tasks:\n    - name: Drop all backend databases\n      community.mysql.mysql_db:\n        login_user: mysqlroot\n        login_password: \"password\"\n        login_host: \"mysqlserver\"\n        name: \"{{ item.0 }}\"\n        state: absent\n      loop: \"{{ db_list_backend | product(environments) }}\"\n</code></pre> <p>Then you would need to call the playbook like this to only delete databases on the dev-environment:</p> <pre><code>ansible-playbook playbook.yaml --extra-vars='{environments: [dev]}'\n</code></pre> <p>But what would happen if you ran the playbook without the <code>extra-vars</code>? All environments would be deleted - probably not what you'd expect.</p>"},{"location":"avoid_sideeffects/#good","title":"Good","text":"<p>Instead of relying on the <code>environments</code> variable being correctly set, you can do two things:</p> <ul> <li>Use a <code>vars_prompt</code> to ask for the environment to be deleted.</li> <li>Since you cannot define allowed variables in a <code>vars-prompt</code>, you can use an <code>assert</code>-task to check for allowed values. This way, you cannot accidentally delete the production databases.</li> </ul> <pre><code>---\n- hosts:\n    - localhost\n  vars:\n    db_list_backend:\n      - cms\n      - fms\n    allowed_environments:\n      - dev\n      - qa\n  vars_prompt:\n    - name: db_environment\n      prompt: \"Attention: This will delete all databases in the desired environment! Please enter the environment (dev, qa):\"\n  tasks:\n    - name: Assert that db_environment is allowed environment\n      ansible.builtin.assert:\n        that: db_environment in allowed_environments\n        fail_msg: \"{{ db_environment }} is not a valid environment\"\n      tags:\n        - always\n\n    - name: Drop all backend databases\n      community.mysql.mysql_db:\n        login_user: mysqlroot\n        login_password: \"password\"\n        login_host: \"mysqlserver\"\n        name: \"{{ item }}\"\n        state: absent\n      loop: \"{{ db_list_backend }}\"\n\n</code></pre> <p>The final <code>ansible-playbook</code> call would look like this:</p> <pre><code>ansible-playbook playbook.yaml --extra-vars=\"db_environment=dev\"\n</code></pre>"},{"location":"name_your_tasks/","title":"Name your tasks and plays","text":"<p>When writing tasks and plays in Ansible naming them is optional. However you should always give useful names to your tasks ands plays.</p>"},{"location":"name_your_tasks/#bad","title":"Bad","text":"<p>When you run a playbook without named tasks, you\u2019ll see the following output.</p> <pre><code>- hosts: all\n  tasks:\n    - ansible.builtin.include_vars: foo.yml\n    - ansible.builtin.yum:\n        name: httpd\n</code></pre> <pre><code>PLAY [localhost]\n********************************\n\nTASK [include_vars]\n********************************\nok: [localhost]\n\nTASK [yum]\n********************************\nok: [localhost]\n</code></pre>"},{"location":"name_your_tasks/#good","title":"Good","text":"<p>When trying to debug failed tasks it\u2019s really helpful to actually know what task failed and what the task should have been doing. Assigning names to your taks will give the following output.</p> <pre><code>- name: install apache\n  hosts: all\n  tasks:\n    - name: include the config vars for the apache\n      ansible.builtin.include_vars: foo.yml\n    - name: install apache with yum\n      ansible.builtin.yum:\n        name: httpd\n</code></pre> <pre><code>PLAY [install apache]\n********************************\n\nTASK [include the config vars for the apache]\n********************************\nok: [localhost]\n\nTASK [install apache with yum]\n********************************\nok: [localhost]\n</code></pre>"},{"location":"prefix_your_variables/","title":"Prefix your variables","text":"<p>You should prefix your variables with the name of the role (or playbook). This makes it easier to know where the variable is used.</p> <p>Here\u2019s an example. Imagine you\u2019re writing a role to install and configure the Apache web-server (you probably don\u2019t have to). The role is named <code>apache</code>. Now you want to create a variable that configures the default listen-port.</p>"},{"location":"prefix_your_variables/#bad","title":"Bad","text":"<pre><code>- hosts: localhost\n  vars:\n    listen_port: 443\n  tasks:\n    - name: configure apache\n      ansible.builtin.template:\n        src: httpd.conf.j2\n        dest: /etc/httpd/conf/httpd.conf\n</code></pre>"},{"location":"prefix_your_variables/#good","title":"Good","text":"<pre><code>- hosts: localhost\n  vars:\n    apache_listen_port: 443\n  tasks:\n    - name: configure apache\n      ansible.builtin.template:\n        src: httpd.conf.j2\n        dest: /etc/httpd/conf/httpd.conf\n</code></pre> <p>Other than the reason mentioned earlier, there\u2019s no ambiguity here. You definitely know that this variable belongs to the apache-role. There could be another role for some other kind of software that also defines a listen-port. With prefixed variables this is not a problem since variables have their own namespace now.</p> <p>By the way, Puppet and Chef are on the advantage here, having namespaces for their roles. Ansible is not designed this way.</p>"},{"location":"prefix_your_variables/#linting","title":"Linting","text":"<p>Since ansible-lint v6.16.1 a new linting rule has been added which says: \"Variables names from within roles should use role_name_ as a prefix.\".</p> <p>Possible error message: var-naming[no-role-prefix]</p> <p>For more information see the official ansible-lint documentation: https://ansible-lint.readthedocs.io/rules/var-naming/#var-naming</p>"},{"location":"separate_production_and_staging_inventory/","title":"Separate production and staging inventory","text":"<p>You can keep your production environment separate from all your other environments by using parted inventory files or even directories for each environment.</p> <p>This makes the inventory files clearer and they don't get too cluttered over time. You can also combine multiple inventory source types in an inventory directory. This can be useful for combining static and dynamic hosts and managing them as one inventory.</p>"},{"location":"separate_production_and_staging_inventory/#bad","title":"Bad","text":"<p>Folder structure:</p> <pre><code>/path/to/your/ansible\n\u251c\u2500\u2500 ansible.cfg\n\u251c\u2500\u2500 group_vars\n\u251c\u2500\u2500 host_vars\n\u251c\u2500\u2500 inventory_file\n\u251c\u2500\u2500 playbooks\n\u251c\u2500\u2500 roles\n</code></pre> <p>File structure:</p> <pre><code>[example_test_web]\nexample_test_web01\n\n[example_live_web]\nexample_live_web01\n\n[example_live:children]\nexample_live_web\n\n[example_test:children]\nexample_test_web\n\n</code></pre>"},{"location":"separate_production_and_staging_inventory/#good","title":"Good","text":"<p>Folder structure</p> <pre><code>/path/to/your/ansible\n\u251c\u2500\u2500 ansible.cfg\n\u251c\u2500\u2500 inventory\n\u2514\u2500\u2500 live\n\u2502   \u251c\u2500\u2500 group_vars\n\u2502   \u2514\u2500\u2500 host_vars\n\u2514\u2500\u2500 test\n    \u251c\u2500\u2500 group_vars\n    \u2514\u2500\u2500 host_vars\n\u251c\u2500\u2500 playbooks\n\u251c\u2500\u2500 roles\n</code></pre> <p>File structure:</p> <p>inventory/live:</p> <pre><code>[example_live_web]\nexample_live_web01\n\n[example_live:children]\nexample_live_web\n</code></pre> <p>inventory/test:</p> <pre><code>[example_test_web]\nexample_test_web01\n\n[example_test:children]\nexample_test_web\n</code></pre>"},{"location":"turn_off_gather_facts/","title":"Turn off gather_facts if you don't need it","text":"<p>If you execute a playbook with <code>yaml gather_facts: true</code>, Ansible starts collecting facts (data from your node that is stored into variables). These details include variables from the remote host such as network configuration variables, hostnames and so on.</p> <p>The collection of these facts is a time-consuming process and in order to speed up the execution of the playbook you can turn gathering facts off.</p>"},{"location":"turn_off_gather_facts/#bad","title":"Bad","text":"<pre><code>---\n - hosts: all\n   become: true\n   gather_facts: true\n   tasks:\n     - name: restart mysql\n       ansible.builtin.service:\n        name: mysql\n        state: restarted\n</code></pre>"},{"location":"turn_off_gather_facts/#good","title":"Good","text":"<pre><code>---\n - hosts: all\n   become: true\n   gather_facts: false\n   tasks:\n     - name: restart mysql\n       ansible.builtin.service:\n        name: mysql\n        state: restarted\n</code></pre> <p>Keep in mind that you need to enable <code>gather_facts</code> if you want to use host-variables or want to collect information about the remote host. A list about some of these Ansible facts can be found here: https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts</p> <p>It is also possible to limit the gathered subsets by using the <code>ansible.builtin.setup</code> module.</p>"},{"location":"turn_off_gather_facts/#example-of-limiting-the-gathered-fact-subsets","title":"Example of limiting the gathered fact subsets","text":"<pre><code>---\n - hosts: all\n   become: true\n   gather_facts: false\n   tasks:\n     - name: gather only distribution facts\n       ansible.builtin.setup:\n       gather_subset:\n         - '!all'\n         - '!min'\n         - distribution\n</code></pre>"},{"location":"use_copy_template_instead_of_lineinfile/","title":"Use copy or template-module instead of lineinfile","text":"<p>It\u2019s often necessary to change single lines in files. When having to do this, many people will use the lineinfile or blockinfile modules to change the file.</p> <p>However over the years I learned that most times you should in fact not use these modules when wanting to changes files. You should rather use the template- or copy-module to manage not only single lines but the whole file itself.</p> <p>The reason for that is twofold. First when using lineinfile you often have to use regex. Now you have two problems. More seriously, using regex is often okay, if the regex is simple (or you and the people using your playbooks are experienced with regex)!</p> <p>The second reason is that you have to know and remember that this particular line in this config-file is managed by Ansible. If you manage the whole file with template you can use the ansible_managed-variable to show that the file is under Ansible control.</p>"},{"location":"use_copy_template_instead_of_lineinfile/#bad","title":"Bad","text":"<pre><code>- ansible.builtin.lineinfile:\n    path: /etc/selinux/config\n    regexp: '^SELINUX='\n    line: 'SELINUX=enforcing'\n</code></pre>"},{"location":"use_copy_template_instead_of_lineinfile/#good","title":"Good","text":"<pre><code>- ansible.builtin.copy:\n    src: \"etc/selinux/config\"\n    dest: \"/etc/selinux/config\"\n</code></pre>"},{"location":"use_copy_template_instead_of_lineinfile/#also-good","title":"Also Good","text":"<pre><code>- ansible.builtin.template:\n    src: \"etc/selinux/config.j2\"\n    dest: \"/etc/selinux/config\"\n</code></pre> <p>with the template file looking like this:</p> <pre><code># {{ansible_managed}}\nSELINUX=enforcing\nSELINUXTYPE=targeted\n</code></pre> <p>Bonus: you can use a variable for the selinux-state and simply change it on servers where selinux should not be in enforcing state.</p>"},{"location":"use_modules_before_run_commands/","title":"Use Modules Before Run Commands","text":"<p>Ansible is batteries-included and comes with more than 6000 modules to help manage systems. Most times it\u2019s not needed (nor useful!) to fall back to shell commands instead of using modules.</p>"},{"location":"use_modules_before_run_commands/#bad","title":"Bad","text":"<pre><code>- name: install htop\n  hosts: all\n  tasks:\n    - name: install htop\n      ansible.builtin.command: \"yum install htop -y\"\n</code></pre>"},{"location":"use_modules_before_run_commands/#good","title":"Good","text":"<pre><code>- name: install htop\n  hosts: all\n  tasks:\n    - name: install htop\n      ansible.builtin.yum:\n        name: \"htop\"\n        state: present\n</code></pre> <p>Ansible is helpful in detecting when you should use modules instead of commands. It detects these uses and prints a warning. When running the above task with command Ansible prints:</p> <pre><code>TASK [command] ***********************\n [WARNING]: Consider using yum module rather than running yum\n</code></pre>"},{"location":"use_native_yaml_syntax/","title":"Use native YAML syntax for your Ansible code","text":"<p>There are several ways you can write your code in Ansible. At its core, the Ansible playbook runner is a YAML parser with added logic such as:</p> <pre><code>commandline key=value\n</code></pre>"},{"location":"use_native_yaml_syntax/#bad","title":"Bad","text":"<p>Using the key=value shorthand format will limit the readability of your code:</p> <pre><code>- name: install telegraf\n  ansible.builtin.yum:\n    name: telegraf-{{ telegraf_version }} state=present update_cache=yes disable_gpg_check=yes enablerepo=telegraf\n  notify: restart telegraf\n\n- name: configure telegraf\n  ansible.builtin.template: src=telegraf.conf.j2 dest=/etc/telegraf/telegraf.conf\n  notify: restart telegraf\n</code></pre>"},{"location":"use_native_yaml_syntax/#good","title":"Good","text":"<p>Using native YAML has a few more lines but it reduces horizontal scrolling and line wrapping. Another benefit is the improved syntax highlighting in modern text editor software.</p> <pre><code>- name: install telegraf\n  ansible.builtin.yum:\n    name: telegraf-{{ telegraf_version }}\n    state: present\n    update_cache: yes\n    disable_gpg_check: yes\n    enablerepo: telegraf\n  notify: restart telegraf\n\n- name: configure telegraf\n  ansible.builtin.template:\n    src: telegraf.conf.j2\n    dest: /etc/telegraf/telegraf\n</code></pre>"}]}